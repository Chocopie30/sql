SELECT *
FROM TAB;

SELECT *
FROM NEW_TABLE;

-- 현재상태 저장
COMMIT;

-- 저장했던 상태로 복구
ROLLBACK;

-- 삭제한 테이블, 휴지통 확인
SELECT *
FROM USER_RECYCLEBIN;

-- 휴지통에서 테이블 복구하기
FLASHBACK TABLE NEW_TABLE TO BEFORE DROP;

-- 테이블 만들기
CREATE TABLE NEW_TABLE (
NO NUMBER(3) PRIMARY KEY, -- 회원번호 1 ~ 999, 중복된 값을 넣을 수 없다
NAME VARCHAR2(10) NOT NULL, -- 이름 최대 10자리, 반드시 값이 들어와야 한다
BIRTH DATE DEFAULT SYSDATE-- 생년월일 TO_DATE('2020-01-01','RRRR-MM-DD'), 값이 없으면 현재 날짜로 지정
);

CREATE TABLE NEW_EMP(
NO NUMBER(4) CONSTRAINT EMP_NO_PK PRIMARY KEY,
NAME VARCHAR2(20) CONSTRAINT EMP_NAME_NN NOT NULL,
JUMIN VARCHAR2(13) CONSTRAINT EMP_JUMIN_NN NOT NULL
                  CONSTRAINT EMP_JUMIN_UK UNIQUE,
LOC_CODE NUMBER(1) CONSTRAINT EMP_AREA_CK CHECK (LOC_CODE < 5),
DEPTNO NUMBER(2) CONSTRAINT EMP_DEPT_FK REFERENCES DEPT (DEPTNO)
);

SELECT *
FROM NEW_EMP;

-- 테이블 컬럼 추가, 이름수정, 유형변경, 삭제
ALTER TABLE NEW_TABLE ADD PHONE VARCHAR2(20);
ALTER TABLE NEW_TABLE RENAME COLUMN PHONE TO TEL;
ALTER TABLE NEW_TABLE MODIFY TEL VARCHAR2(30);
ALTER TABLE NEW_TABLE DROP COLUMN TEL;

-- 가상 컬럼 추가
ALTER TABLE NEW_TABLE ADD INFO GENERATED ALWAYS AS (NO || '-' || NAME);

-- 테이블 읽기 전용으로 변경, 데이터 변경 불가 조회만 가능
ALTER TABLE NEW_TABLE READ ONLY;

-- 테이블 안에 공간은 남기고 데이터만 삭제
DELETE FROM NEW_TABLE
WHERE NO =1;

-- 테이블 안에 데이터 공간까지 다 삭제
TRUNCATE TABLE NEW_TABLE;

-- 테이블 삭제
DROP TABLE NEW_TABLE;
-- 테이블 완전 삭제 (휴지통에 넣지않고 삭제)
DROP TABLE NEW_TABLE PURGE;

--테이블 정보 확인
DESC NEW_TABLE; 

-- 데이터 추가 수정 삭제
-- 1번 홍동이
INSERT INTO NEW_TABLE (NO, NAME)
VALUES(1,'홍동');
--2번 뽀또
INSERT INTO NEW_TABLE (NO, NAME, BIRTH)
VALUES(2,'뽀또','2001-01-01');
--1번 홍동이 전화번호 수정
UPDATE NEW_TABLE
SET PHONE = '010-1111-1111'
WHERE NO = 1;
--2번 뽀또 생일 전화번호 수정
UPDATE NEW_TABLE
SET PHONE = '010-2222-2222',
    BIRTH = TO_DATE('2001-02-02','RRRR-MM-DD')
WHERE NO = 2;

-------------------------------------------------

SELECT *
FROM DEPT2
ORDER BY DCODE;

DESC DEPT2;

-- INSERT INTO 테이블 (구조 순서에 맞게) VALUES (데이터 넣기)
INSERT INTO DEPT2 (DCODE, PDEPT,DNAME, AREA)
VALUES ('9001','1006','TEMP_2','TEMP AREA');

SELECT *
FROM PROFESSOR3;

-- 구조만 복사, 데이터는 X / CTAS
CREATE TABLE PROFESSOR3
AS SELECT *
FROM PROFESSOR
WHERE 1 =2 ;

-- ITAS
INSERT INTO PROFESSOR3
SELECT *
FROM PROFESSOR;

-- 테이블이 만들어지면 자동으로 커밋이 된다
CREATE TABLE PROF_1 (
PROFNO NUMBER,
NAME VARCHAR(25)
);

CREATE TABLE PROF_2 (
PROFNO NUMBER,
NAME VARCHAR(25)
);

INSERT ALL
  WHEN PROFNO BETWEEN 1000 AND 1999 THEN INTO PROF_1 VALUES(PROFNO, NAME)
  WHEN PROFNO BETWEEN 2000 AND 2999 THEN INTO PROF_2 VALUES(PROFNO, NAME)
  SELECT PROFNO, NAME
  FROM PROFESSOR;

INSERT ALL
      INTO PROF_1 VALUES (PROFNO, NAME)
      INTO PROF_2 VALUES (PROFNO, NAME)
      SELECT PROFNO, NAME
      FROM PROFESSOR;

SELECT *
FROM PROF_1;

SELECT *
FROM PROF_2;

SELECT *
FROM PROFESSOR;

-- HPAGE 있는 사람 지우기
DELETE FROM PROFESSOR
WHERE HPAGE IS NOT NULL;

-- HPAGE를 이메일 회사의 홈페이로 넣기
UPDATE PROFESSOR
SET BONUS = DECODE (BONUS,NULL,100,BONUS ),
    PAY = PAY + (PAY *0.1),
    HPAGE = 'http://www.'||SUBSTR(EMAIL,INSTR(EMAIL,'@')+1,20)
WHERE 1=1;

SELECT *
FROM DEPT;

-- 참조하는 자식이 있어 삭제 안됨
DELETE FROM DEPT
WHERE DEPTNO = 30;
-- 그래서 참조하는 애들 삭제하기
DELETE FROM EMP
WHERE DEPTNO = 30;

SELECT *
FROM EMP;

UPDATE EMP
SET DEPTNO = 50
WHERE DEPTNO = 20;

SELECT *
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO;

-- WHERE EXISTS 조건문
UPDATE EMP E
SET SAL = SAL +100
WHERE EXISTS (SELECT 1
              FROM DEPT D
              WHERE E.DEPTNO = D.DEPTNO
              AND D.LOC = 'DALLAS');
              
--게시판, 회원관리, 상품관리 -> 프로젝트
-- 오라클서버 --- 웹서버(노드) --- 클라이언트(fetch)

SELECT *
FROM EMP;

DESC EMP;

INSERT INTO EMP(EMPNO, ENAME, JOB, HIREDATE, DEPTNO)
VALUES (9999, 'KONG','SALESMAN',TO_DATE('1982-03-01','RRRR-MM-DD'), 30);

SELECT *
FROM PROFESSOR;

SELECT *
FROM STUDENT;

-- RENE RUSSO 학생의 담당교수의 번호, 이름, POSITION 확인
SELECT P.PROFNO
      ,P.NAME
      ,P.POSITION
FROM PROFESSOR P
JOIN STUDENT S
ON p.profno = s.profno
WHERE S.NAME = 'Rene Russo';

SELECT *
FROM DEPARTMENT;

-- 전공: 'Computer Engineering' 학생들의 학번 이름 확인
SELECT S.STUDNO
      ,S.NAME
FROM STUDENT S
JOIN DEPARTMENT D
ON S.DEPTNO1 = D.DEPTNO
WHERE D.DNAME = 'Computer Engineering';

-- 전공1, 전공2든 컴퓨터 엔지니어링 학생들 학번 이름 확인
SELECT S.STUDNO
      ,S.NAME
FROM STUDENT S
JOIN DEPARTMENT D
ON S.DEPTNO1 = D.DEPTNO
OR DEPTNO2 = D.DEPTNO
WHERE D.DNAME = 'Computer Engineering';

-- 전공1 학생중에 컴퓨터 엔지니어링 학생들의 담당교수의 교수번호, 이름, POSITION 확인
SELECT DISTINCT P.PROFNO
      ,P.NAME
      ,P.POSITION
FROM PROFESSOR P
JOIN STUDENT S
ON P.PROFNO = S.PROFNO
JOIN DEPARTMENT D
ON D.DEPTNO = S.DEPTNO1
WHERE d.dname = 'Computer Engineering';

SELECT *
FROM PROFESSOR;

SELECT *
FROM STUDENT;

-- 교수
SELECT S.STUDNO
      ,S.NAME
FROM STUDENT S
JOIN PROFESSOR P
ON S.PROFNO = P.PROFNO
WHERE P.POSITION = 'assistant professor';

-- 학생전공 'Computer Engneering' 학생 중에서 몸무게 평균 / 평균보다 무거운 친구
SELECT *
FROM STUDENT SS
WHERE SS.WEIGHT >
(SELECT AVG(WEIGHT)
FROM STUDENT S
JOIN DEPARTMENT D
ON D.DEPTNO = S.DEPTNO1
WHERE D.DNAME = 'Computer Engineering');

-- 전공이 Electronic Engineering 학생들의 담당교수 
SELECT *
FROM PROFESSOR PP
WHERE PP.PROFNO IN (SELECT P.PROFNO
                    FROM PROFESSOR P
                    JOIN STUDENT S
                    ON P.PROFNO = S.PROFNO
                    JOIN DEPARTMENT D
                    ON S.DEPTNO1 = D.DEPTNO
                    WHERE D.DNAME = 'Electronic Engineering');
                    
-- 평균이상의 급여를 받는 교수 번호, 이름 출력
SELECT PROFNO
      ,NAME
FROM PROFESSOR
WHERE PAY >(SELECT AVG(PAY)
FROM PROFESSOR);

-- 교수 보너스 없는 사람들 중 제일 먼저 입사한 사람보다 먼저 입사한 사람들 출력
SELECT NAME
      ,HIREDATE
FROM PROFESSOR
WHERE HIREDATE <(SELECT MIN(HIREDATE)
FROM PROFESSOR
WHERE BONUS IS NULL)
ORDER BY 2;

SELECT *
FROM PROFESSOR;

-- 교수 보너스 안받는 사람중 월급 제일 많이 받는 사람보다 보너스 받고도 월급이 적은 사람들 월급 10프로 인상
UPDATE PROFESSOR
SET PAY = PAY+(PAY*0.1)
WHERE BONUS IS NOT NULL
AND PAY <(SELECT MAX(PAY)
FROM PROFESSOR
WHERE BONUS IS NULL);

select *
FROM dept;

-- view : 조인해서 새로운 테이블을 만듬
CREATE OR REPLACE VIEW EMP_DEPT_V
AS
SELECT EMPNO, ENAME, JOB, SAL, E.DEPTNO, DNAME
FROM EMP E
JOIN DEPT D
ON E.DEPTNO = D.DEPTNO;

SELECT *
FROM EMP_DEPT_V;

CREATE OR REPLACE VIEW EMP_V
AS
SELECT EMPNO, ENAME, JOB, DEPTNO
FROM EMP;

SELECT *
FROM EMP_V;

SELECT *
FROM TAB;

CREATE OR REPLACE VIEW STUD_PROF_V
AS
SELECT STUDNO
      ,S.NAME STUDNAME
      ,S.BIRTHDAY
      ,S.TEL
      ,S.DEPTNO1 DEPTNO
      ,P.PROFNO
      ,P.NAME PROFNAME
      ,P.POSITION
      ,P.EMAIL
FROM STUDENT S
LEFT OUTER JOIN PROFESSOR P
ON S.PROFNO = P.PROFNO;

SELECT V.*, D.DNAME
FROM STUD_PROF_V V
JOIN DEPARTMENT D
ON V.DEPTNO = D.DEPTNO
WHERE POSITION ='a full professor';

-- VIEW는 업데이트 하지말기, 조회용으로 사용
UPDATE EMP_V
SET ENAME =''
WHERE EMPNO = '9999';

SELECT *
FROM EMP_V;

CREATE TABLE BOARD_T (
BOARD_NO NUMBER(5) PRIMARY KEY,
TITLE VARCHAR2(100) NOT NULL,
CONTENT VARCHAR2(1000) NOT NULL,
WRITER VARCHAR2(50) NOT NULL,
WRITE_DATE DATE DEFAULT SYSDATE,
LIKES NUMBER(3) DEFAULT 0
);

ALTER TABLE BOARD_T MODIFY BOARD_NO NUMBER(10);

SELECT *
FROM BOARD_T;

--시퀀스 사용 
CREATE SEQUENCE BOARD_T_SEQ;
-- 100부터 시작, 2씩증가, 최대 120, 최소 80, 끝나면 최소부터 시작
CREATE SEQUENCE BOARD_T_SEQ
INCREMENT BY 2
START WITH 100
MAXVALUE 120
MINVALUE 80
CYCLE;
--시퀀스 삭제
DROP SEQUENCE BOARD_T_SEQ;
-- 사용할때마다 +1되어 출력
SELECT BOARD_T_SEQ.NEXTVAL FROM DUAL;

-- 내용넣기
INSERT INTO BOARD_T (BOARD_NO, TITLE, CONTENT, WRITER)
VALUES (BOARD_T_SEQ.NEXTVAL,'삭제?','DELETE FROM 테이블 WHERE 조건','지식IN');


--내용삭제
DELETE FROM BOARD_T;